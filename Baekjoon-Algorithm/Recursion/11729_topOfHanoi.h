#pragma once

#include <iostream>
#include <stack>
#include <memory.h>
#include <cmath>

/*
############################################################################
############################################################################
############################################################################
############################### Fail #######################################
############################################################################
############################################################################
############################################################################
*/

// 하노이 탑 시뮬레이터를 돌려보면서, 코드를 어떻게 짜야할 지 생각해봤음.
// 재귀로 뭔가 어떻게 하면 좋을 것 같긴 했는데, 도저히 코드로 짜지질 않았고,
// 구글링 해서 다른 사람 코드를 한참 쳐다본 다음에야 이해할 수 있었음

using namespace std;

// 아래 풀이 방식은 재귀, 분할 정복으로 볼 수 있다.
void solve(int n, int source, int by, int dest) {
    if(n == 1){
        cout << source << " " << dest << "\n";
        return;
    }

    solve(n-1, source, dest , by);
    cout << source << " " << dest << "\n";
    solve(n-1, by, source, dest);
}

// 아래 풀이에서 6이 의미하는게 뭔지 모르겠음.
void other_solve_solution(int n, int x, int y) {
    if (n == 0) return;
    //x+y+z=6 - > 6-x-y = z;
    other_solve_solution(n - 1, x, 6 - x - y);
    //n번째 탑
    printf("%d %d\n", x, y);
    other_solve_solution(n - 1, 6 - x - y, y);

}

void solve_11729(){
    int n;
    cin >> n;

    cout << (int) pow(2, n) - 1 << "\n";
    solve(n, 1, 2, 3);

    // solve_solution(n, 1, 3);
}